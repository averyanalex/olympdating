use std::sync::Arc;

use anyhow::{anyhow, bail, Context, Result};
use bitflags::bitflags;
use chrono::Datelike;
use db::Database;
use entities::sea_orm_active_enums::Gender;
use itertools::Itertools;
use teloxide::{
    adaptors::{throttle::Limits, Throttle},
    dispatching::dialogue::InMemStorage,
    prelude::*,
    types::{
        Chat, ChatKind, InlineKeyboardButton, InlineKeyboardMarkup,
        KeyboardButton, KeyboardMarkup, KeyboardRemove,
    },
    utils::command::BotCommands,
};

mod db;

type Bot = Throttle<teloxide::Bot>;
type ProfileCreationDialogue =
    Dialogue<ProfileCreationState, InMemStorage<ProfileCreationState>>;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    tracing::info!("Starting bot...");
    let bot = teloxide::Bot::from_env()
        .throttle(Limits { messages_per_min_chat: 30, ..Default::default() });

    let handler = dptree::entry()
        .enter_dialogue::<Update, InMemStorage<ProfileCreationState>, ProfileCreationState>()
        .branch(
            Update::filter_message()
                .branch(dptree::case![ProfileCreationState::SetName(a)].endpoint(handle_set_name))
                .branch(dptree::case![ProfileCreationState::SetGender(a)].endpoint(handle_set_gender))
                .branch(dptree::case![ProfileCreationState::SetPartnerGender(a)].endpoint(handle_set_partner_gender))
                .branch(dptree::case![ProfileCreationState::SetGraduationYear(a)].endpoint(handle_set_graduation_year))
                .branch(dptree::case![ProfileCreationState::SetAbout(a)].endpoint(handle_set_about))
                .branch(
                    dptree::entry()
                        .filter_command::<Command>()
                        .endpoint(answer),
                )
                .branch(dptree::endpoint(invalid_command)),
        )
        .branch(
            Update::filter_callback_query()
                .branch(
                    dptree::case![ProfileCreationState::SetSubjects(a)]
                        .endpoint(handle_set_subjects_callback),
                )
                .branch(
                    dptree::case![ProfileCreationState::SetPartnerSubjects(a)]
                        .endpoint(handle_set_partner_subjects_callback),
                )
        );

    let database = db::Database::new().await?;

    Dispatcher::builder(bot, handler)
        .dependencies(dptree::deps![
            InMemStorage::<ProfileCreationState>::new(),
            Arc::new(database)
        ])
        .enable_ctrlc_handler()
        .build()
        .dispatch()
        .await;
    Ok(())
}

bitflags! {
    #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, Hash)]
    struct Subjects: i64 {
        const Art = 1 << 0;
        const Astronomy = 1 << 1;
        const Biology = 1 << 2;
        const Chemistry = 1 << 3;
        const Chinese = 1 << 4;
        const Ecology = 1 << 5;
        const Economics = 1 << 6;
        const English = 1 << 7;
        const French = 1 << 8;
        const Geography = 1 << 9;
        const German = 1 << 10;
        const History = 1 << 11;
        const Informatics = 1 << 12;
        const Italian = 1 << 13;
        const Law = 1 << 14;
        const Literature = 1 << 15;
        const Math = 1 << 16;
        const Physics = 1 << 17;
        const Russian = 1 << 18;
        const Safety = 1 << 19;
        const Social = 1 << 20;
        const Spanish = 1 << 21;
        const Sport = 1 << 22;
        const Technology = 1 << 23;
    }
}

#[derive(Clone, Default)]
struct NewProfile {
    name: Option<String>,
    gender: Option<Gender>,
    graduation_year: Option<i16>,
    subjects: Option<Subjects>,
    partner_subjects: Option<Subjects>,
    about: Option<String>,
    target_gender: Option<Gender>,
}

#[derive(Debug)]
struct Profile {
    name: String,
    gender: Gender,
    graduation_year: i16,
    subjects: Subjects,
    partner_subjects: Subjects,
    about: String,
    partner_gender: Option<Gender>,
}

impl TryFrom<NewProfile> for Profile {
    type Error = anyhow::Error;

    fn try_from(new: NewProfile) -> Result<Self, Self::Error> {
        match new {
            NewProfile {
                name: Some(name),
                gender: Some(gender),
                graduation_year: Some(grade),
                subjects: Some(subjects),
                partner_subjects: Some(partner_subjects),
                about: Some(about),
                target_gender,
            } => Ok(Profile {
                name,
                gender,
                graduation_year: grade,
                subjects,
                partner_subjects,
                about,
                partner_gender: target_gender,
            }),
            _ => Err(anyhow!("can't create Profile from NewProfile")),
        }
    }
}

#[derive(Clone, Default)]
enum ProfileCreationState {
    #[default]
    Start,
    SetName(NewProfile),
    SetGender(NewProfile),
    SetPartnerGender(NewProfile),
    SetGraduationYear(NewProfile),
    SetSubjects(NewProfile),
    SetPartnerSubjects(NewProfile),
    SetAbout(NewProfile),
}

async fn request_set_name(bot: Bot, chat: Chat) -> Result<()> {
    match chat.kind {
        ChatKind::Public(_) => Err(anyhow!("chat isn't private")),
        ChatKind::Private(p) => match p.first_name {
            Some(n) => {
                let keyboard = vec![vec![KeyboardButton::new(n)]];
                let keyboard_markup =
                    KeyboardMarkup::new(keyboard).resize_keyboard(true);
                bot.send_message(chat.id, text::EDIT_NAME)
                    .reply_markup(keyboard_markup)
                    .await?;
                Ok(())
            }
            None => {
                bot.send_message(chat.id, text::EDIT_NAME).await?;
                Ok(())
            }
        },
    }
}

async fn handle_set_name(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    mut profile: NewProfile,
) -> Result<()> {
    match msg.text() {
        Some(text) if (3..=30).contains(&text.len()) => {
            profile.name = Some(text.to_owned());
            dialogue.update(ProfileCreationState::SetGender(profile)).await?;

            request_set_gender(bot, msg.chat).await?;
        }
        _ => {
            request_set_name(bot, msg.chat).await?;
        }
    }
    Ok(())
}

async fn request_set_gender(bot: Bot, chat: Chat) -> Result<()> {
    let keyboard = vec![vec![
        KeyboardButton::new("–ú—É–∂—Å–∫–æ–π"),
        KeyboardButton::new("–ñ–µ–Ω—Å–∫–∏–π"),
    ]];
    let keyboard_markup = KeyboardMarkup::new(keyboard).resize_keyboard(true);

    bot.send_message(chat.id, text::EDIT_GENDER)
        .reply_markup(keyboard_markup)
        .await?;
    Ok(())
}

async fn handle_set_gender(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    mut profile: NewProfile,
) -> Result<()> {
    let Some(text) = msg.text() else {bail!("no text in message")};
    let gender = match text {
        "–ú—É–∂—Å–∫–æ–π" => Gender::Male,
        "–ñ–µ–Ω—Å–∫–∏–π" => Gender::Female,
        &_ => {
            request_set_gender(bot, msg.chat).await?;
            return Ok(());
        }
    };

    profile.gender = Some(gender);
    dialogue.update(ProfileCreationState::SetPartnerGender(profile)).await?;

    request_set_partner_gender(bot, msg.chat).await?;

    Ok(())
}

async fn request_set_partner_gender(bot: Bot, chat: Chat) -> Result<()> {
    let keyboard = vec![
        vec![KeyboardButton::new("–ü–∞—Ä–µ–Ω—å"), KeyboardButton::new("–î–µ–≤—É—à–∫–∞")],
        vec![KeyboardButton::new("–ù–µ –≤–∞–∂–Ω–æ")],
    ];
    let keyboard_markup = KeyboardMarkup::new(keyboard).resize_keyboard(true);

    bot.send_message(chat.id, text::EDIT_PARTNER_GENDER)
        .reply_markup(keyboard_markup)
        .await?;
    Ok(())
}

async fn handle_set_partner_gender(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    mut profile: NewProfile,
) -> Result<()> {
    let Some(text) = msg.text() else {bail!("no text in message")};
    let gender = match text {
        "–ü–∞—Ä–µ–Ω—å" => Some(Gender::Male),
        "–î–µ–≤—É—à–∫–∞" => Some(Gender::Female),
        "–ù–µ –≤–∞–∂–Ω–æ" => None,
        &_ => {
            request_set_partner_gender(bot, msg.chat).await?;
            return Ok(());
        }
    };

    profile.target_gender = gender;
    dialogue.update(ProfileCreationState::SetGraduationYear(profile)).await?;

    request_set_graduation_year(bot, msg.chat).await?;

    Ok(())
}

async fn request_set_graduation_year(bot: Bot, chat: Chat) -> Result<()> {
    let keyboard =
        (6..=11).map(|n| KeyboardButton::new(n.to_string())).chunks(3);
    let keyboard_markup =
        KeyboardMarkup::new(keyboard.into_iter()).resize_keyboard(true);

    bot.send_message(chat.id, text::REQUEST_GRADE)
        .reply_markup(keyboard_markup)
        .await?;
    Ok(())
}

async fn handle_set_graduation_year(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    mut profile: NewProfile,
) -> Result<()> {
    let Some(text) = msg.text() else {bail!("no text in message")};
    let Ok(grade) = text.parse::<i32>() else {request_set_graduation_year(bot, msg.chat).await?; return Ok(())};

    let date = chrono::Local::now();

    let graduation_year = if date.month() < 9 {
        date.year() + (11 - grade)
    } else {
        date.year() + (11 - grade) + 1
    };

    profile.graduation_year = Some(graduation_year as i16);
    request_set_subjects(bot, msg.chat).await?;
    dialogue.update(ProfileCreationState::SetSubjects(profile)).await?;

    Ok(())
}

fn subject_name(subject: Subjects) -> Result<&'static str> {
    Ok(match subject {
        Subjects::Art => "–ò—Å–∫—É—Å—Å—Ç–≤–æ üé®",
        Subjects::Astronomy => "–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—è üåå",
        Subjects::Biology => "–ë–∏–æ–ª–æ–≥–∏—è üî¨",
        Subjects::Chemistry => "–•–∏–º–∏—è üß™",
        Subjects::Chinese => "–ö–∏—Ç–∞–π—Å–∫–∏–π üá®üá≥",
        Subjects::Ecology => "–≠–∫–æ–ª–æ–≥–∏—è ‚ôªÔ∏è",
        Subjects::Economics => "–≠–∫–æ–Ω–æ–º–∏–∫–∞ üí∂",
        Subjects::English => "–ê–Ω–≥–ª–∏–π—Å–∫–∏–π üá¨üáß",
        Subjects::French => "–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π üá´üá∑",
        Subjects::Geography => "–ì–µ–æ–≥—Ä–∞—Ñ–∏—è üåé",
        Subjects::German => "–ù–µ–º–µ—Ü–∫–∏–π üá©üá™",
        Subjects::History => "–ò—Å—Ç–æ—Ä–∏—è üì∞",
        Subjects::Informatics => "–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞ üíª",
        Subjects::Italian => "–ò—Ç–∞–ª—å—è–Ω—Å–∫–∏–π üáÆüáπ",
        Subjects::Law => "–ü—Ä–∞–≤–æ üë®‚Äç‚öñÔ∏è",
        Subjects::Literature => "–õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞ üìñ",
        Subjects::Math => "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ üìê",
        Subjects::Physics => "–§–∏–∑–∏–∫–∞ ‚ò¢Ô∏è",
        Subjects::Russian => "–†—É—Å—Å–∫–∏–π üá∑üá∫",
        Subjects::Safety => "–û–ë–ñ ü™ñ",
        Subjects::Social => "–û–±—â–µ—Å—Ç–≤–æ–∑–Ω–∞–Ω–∏–µ üë´",
        Subjects::Spanish => "–ò—Å–ø–∞–Ω—Å–∫–∏–π üá™üá∏",
        Subjects::Sport => "–§–∏–∑–∫—É–ª—å—Ç—É—Ä–∞ üèê",
        Subjects::Technology => "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è üöú",
        _ => bail!("unknown subject"),
    })
}

// fn make_subjects_keyboard(selected: Subjects) -> InlineKeyboardMarkup {
//     let mut keyboard = Vec::new();

//     macro_rules! add_subjects {
//         ($type:expr, $subjects:expr) => {
//             keyboard.push(vec![InlineKeyboardButton::callback($type,
// $type)]);             keyboard.extend(
//                 $subjects
//                     .into_iter()
//                     .map(|s| {
//                         InlineKeyboardButton::callback(
//                             if selected.contains(s) {
//                                 format!("‚úÖ {}", subject_name(s).unwrap())
//                             } else {
//                                 subject_name(s).unwrap().to_owned()
//                             },
//                             s.bits().to_string(),
//                         )
//                     })
//                     .chunks(3)
//                     .into_iter()
//                     .map(|r| r.collect()),
//             );
//         };
//     }

//     add_subjects!(text::SUBJECTS_HUMANITARIAN, [
//         Subjects::Art,
//         Subjects::Geography,
//         Subjects::History,
//         Subjects::Law,
//         Subjects::Literature,
//         Subjects::Social
//     ]);
//     add_subjects!(text::SUBJECTS_TECHNICAL, [
//         Subjects::Astronomy,
//         Subjects::Chemistry,
//         Subjects::Economics,
//         Subjects::Informatics,
//         Subjects::Math,
//         Subjects::Physics,
//     ]);
//     add_subjects!(text::SUBJECTS_LANGUAGES, [
//         Subjects::Chinese,
//         Subjects::English,
//         Subjects::French,
//         Subjects::German,
//         Subjects::Italian,
//         Subjects::Spanish
//     ]);
//     add_subjects!(text::SUBJECTS_OTHER, [
//         Subjects::Biology,
//         Subjects::Ecology,
//         Subjects::Russian,
//         Subjects::Safety,
//         Subjects::Sport,
//         Subjects::Technology,
//     ]);

//     keyboard.push(vec![InlineKeyboardButton::callback(
//         text::SUBJECTS_CONTINUE,
//         text::SUBJECTS_CONTINUE,
//     )]);
//     InlineKeyboardMarkup::new(keyboard)
// }

fn make_subjects_keyboard(selected: Subjects) -> InlineKeyboardMarkup {
    let mut keyboard: Vec<_> = Subjects::all()
        .iter_names()
        .chunks(3)
        .into_iter()
        .map(|row| {
            row.map(|(_, val)| {
                InlineKeyboardButton::callback(
                    if selected.contains(val) {
                        format!("‚úÖ {}", subject_name(val).unwrap())
                    } else {
                        subject_name(val).unwrap().to_owned()
                    },
                    val.bits().to_string(),
                )
            })
            .collect()
        })
        .collect();

    keyboard.push(vec![InlineKeyboardButton::callback(
        text::SUBJECTS_CONTINUE,
        text::SUBJECTS_CONTINUE,
    )]);
    InlineKeyboardMarkup::new(keyboard)
}

async fn request_set_subjects(bot: Bot, chat: Chat) -> Result<()> {
    bot.send_message(chat.id, "* –∫–æ—Å—Ç—ã–ª—å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã *")
        .reply_markup(KeyboardRemove::new())
        .await?;
    bot.send_message(chat.id, text::EDIT_SUBJECTS)
        .reply_markup(make_subjects_keyboard(Subjects::default()))
        .await?;
    Ok(())
}

async fn handle_set_subjects_callback(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    mut profile: NewProfile,
    q: CallbackQuery,
) -> anyhow::Result<()> {
    let text = q.data.context("callback data not provided")?;
    let msg = q.message.context("callback without message")?;

    if text == text::SUBJECTS_CONTINUE {
        bot.edit_message_reply_markup(msg.chat.id, msg.id).await?;
        dialogue
            .update(ProfileCreationState::SetPartnerSubjects(profile))
            .await?;
        request_set_partner_subjects(bot, msg.chat).await?;
    } else {
        let subjects = profile.subjects.unwrap_or_default()
            ^ Subjects::from_bits(text.parse()?).context("subjects error")?;
        profile.subjects = Some(subjects);
        bot.edit_message_reply_markup(msg.chat.id, msg.id)
            .reply_markup(make_subjects_keyboard(subjects))
            .await?;
        dialogue.update(ProfileCreationState::SetSubjects(profile)).await?;
    }
    Ok(())
}

async fn request_set_partner_subjects(bot: Bot, chat: Chat) -> Result<()> {
    bot.send_message(chat.id, text::EDIT_PARTNER_SUBJECTS)
        .reply_markup(make_subjects_keyboard(Subjects::default()))
        .await?;
    Ok(())
}

async fn handle_set_partner_subjects_callback(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    mut profile: NewProfile,
    q: CallbackQuery,
) -> anyhow::Result<()> {
    let text = q.data.context("callback data not provided")?;
    let msg = q.message.context("callback without message")?;

    if text == text::SUBJECTS_CONTINUE {
        bot.edit_message_reply_markup(msg.chat.id, msg.id).await?;
        dialogue.update(ProfileCreationState::SetAbout(profile)).await?;
        request_set_about(bot, msg.chat).await?;
    } else {
        let subjects = profile.partner_subjects.unwrap_or_default()
            ^ Subjects::from_bits(text.parse()?).context("subjects error")?;
        profile.partner_subjects = Some(subjects);
        bot.edit_message_reply_markup(msg.chat.id, msg.id)
            .reply_markup(make_subjects_keyboard(subjects))
            .await?;
        dialogue
            .update(ProfileCreationState::SetPartnerSubjects(profile))
            .await?;
    }
    Ok(())
}

async fn request_set_about(bot: Bot, chat: Chat) -> Result<()> {
    bot.send_message(chat.id, text::EDIT_ABOUT).await?;
    Ok(())
}

async fn handle_set_about(
    db: Arc<Database>,
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    mut profile: NewProfile,
) -> Result<()> {
    match msg.text() {
        Some(text) if (1..=1000).contains(&text.len()) => {
            dialogue.exit().await?;
            profile.about = Some(text.to_owned());
            let profile = Profile::try_from(profile)?;
            db.create_user(
                msg.chat.id.0,
                profile.name,
                profile.about,
                profile.gender,
                profile.partner_gender,
                profile.graduation_year,
                profile.subjects.0 .0,
                profile.partner_subjects.bits(),
            )
            .await?;
        }
        _ => {
            request_set_about(bot, msg.chat).await?;
        }
    }
    Ok(())
}

#[derive(Debug, BotCommands, Clone)]
#[command(rename_rule = "lowercase", description = "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:")]
enum Command {
    #[command(description = "–Ω–æ–≤–∞—è –∞–Ω–∫–µ—Ç–∞")]
    NewProfile,
    #[command(description = "–∏–∑–º–µ–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É")]
    EditProfile,
    // #[command(description = "–≤–∫–ª—é—á–∏—Ç—å –∞–Ω–∫–µ—Ç—É")]
    // EnableAnketa,
    // #[command(description = "–≤—ã–∫–ª—é—á–∏—Ç—å –∞–Ω–∫–µ—Ç–∞")]
    // DisableAnketa,
    Help,
}

mod text {
    pub const EDIT_NAME: &str = "–£–∫–∞–∂–∏—Ç–µ –≤–∞—à–µ –∏–º—è (3-20 —Å–∏–º–≤–æ–ª–æ–≤)";
    pub const EDIT_GENDER: &str = "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à –ø–æ–ª";
    pub const REQUEST_GRADE: &str = "–í –∫–∞–∫–æ–º –≤—ã —Å–µ–π—á–∞—Å –∫–ª–∞—Å—Å–µ?";
    pub const EDIT_SUBJECTS: &str = "–ö–∞–∫–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã –≤—ã –±–æ—Ç–∞–µ—Ç–µ? –ù–∞–∂–º–∏—Ç–µ –Ω–∞ \
                                     –ø—Ä–µ–¥–º–µ—Ç, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ —É–±—Ä–∞—Ç—å –µ–≥–æ.";
    pub const EDIT_PARTNER_SUBJECTS: &str =
        "–ö–∞–∫–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã –¥–æ–ª–∂–µ–Ω –±–æ—Ç–∞—Ç—å —Ç–æ—Ç, –∫–æ–≥–æ –≤—ã –∏—â–µ—Ç–µ? –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç, \
         —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ —É–±—Ä–∞—Ç—å –µ–≥–æ. –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–¥–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è. –ï—Å–ª–∏ \
         –≤–∞–º –Ω–µ –≤–∞–∂–Ω–æ, —á—Ç–æ –æ–Ω –±–æ—Ç–∞–µ—Ç, –Ω–µ –≤—ã–±–∏—Ä–∞–π—Ç–µ –Ω–∏—á–µ–≥–æ.";
    pub const EDIT_ABOUT: &str = "–ù–µ–º–Ω–æ–≥–æ —Ä–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ —Å–µ–±–µ";
    pub const EDIT_PARTNER_GENDER: &str = "–ö–æ–≥–æ –≤—ã –∏—â–µ—Ç–µ?";
    pub const SUBJECTS_CONTINUE: &str = "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å";
    // pub const SUBJECTS_HUMANITARIAN: &str = "–ì—É–º–∞–Ω–∏—Ç–∞—Ä–Ω—ã–µ";
    // pub const SUBJECTS_TECHNICAL: &str = "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ";
    // pub const SUBJECTS_LANGUAGES: &str = "–Ø–∑—ã–∫–æ–≤—ã–µ";
    // pub const SUBJECTS_OTHER: &str = "–î—Ä—É–≥–∏–µ";
}

// #[tracing::instrument(skip(db, bot))]
async fn answer(
    bot: Bot,
    dialogue: ProfileCreationDialogue,
    msg: Message,
    cmd: Command,
) -> anyhow::Result<()> {
    match cmd {
        Command::NewProfile => {
            dialogue
                .update(ProfileCreationState::SetName(NewProfile::default()))
                .await?;
            request_set_name(bot, msg.chat).await?;
        }
        Command::EditProfile => {
            // if get_anketa(msg.chat.id.0).await?.is_some() {
            //     dialogue.update(State::NewName(NewProfile::default())).await?
            // ;     bot.send_message(msg.chat.id,
            // EDIT_NAME_TEXT).await?; } else {
            //     bot.send_message(msg.chat.id, "–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –∞–Ω–∫–µ—Ç—É")
            //         .await?;
            // }
        }
        Command::Help => {
            bot.send_message(msg.chat.id, Command::descriptions().to_string())
                .await?;
        }
    }

    Ok(())
}

async fn invalid_command(bot: Bot, msg: Message) -> anyhow::Result<()> {
    bot.send_message(msg.chat.id, Command::descriptions().to_string()).await?;
    Ok(())
}
